#!/usr/bin/env node

var fs = require('fs'),
    commonmark = require('commonmark'),
    moment = require('moment'),
    ssiParser = require('tiny-ssi'),
    hb = require('handlebars'),
    path = require('path');

var args = process.argv.slice(2);
var layoutPathPrefix = path.resolve(args[2]); //expect it to have trailing slash
var forced = args[3]=="--force" || false;
var compiledLayouts = {};
var collectionPages = [];
var collectionJson = [];

hb.registerHelper('json', function(obj) {
  return JSON.stringify(obj);
});

if(layoutPathPrefix.slice(-1) !== '/') layoutPathPrefix += '/';

function stripExtension(fileName) {
  return fileName.substr(0, fileName.lastIndexOf('.'));
}

function renderToHtml(inputFilePath, outputFilePath) {
  var fileContent = fs.readFileSync(inputFilePath, 'utf8');
  var res = processMarkupContent(fileContent);
  if(res.frontmatter) {
    if (res.frontmatter.mode == 'collection'){
      collectionPages.push({
        inputFilePath: inputFilePath,
        outputFilePath: outputFilePath,
        content: res
      });
    }
    else{
      processContentAndSaveFile(inputFilePath, outputFilePath, res);
      if(res.frontmatter.json){
        collectionJson.push(res.frontmatter.json);
      }
    }
  } else {
    console.warn(inputFilePath + " is missing the Frontmatter section!")
  }
}

function processContentAndSaveFile(inputFilePath, outputFilePath, sourceContent){
  sourceContent.frontmatter.date = sourceContent.frontmatter.date ? moment(sourceContent.frontmatter.date).format('MMMM Do YYYY') : moment().format('MMMM Do YYYY');

  sourceContent.frontmatter.layout = sourceContent.frontmatter.layout || "layout"; //default to page layout

  var layoutHTML = compiledLayouts[sourceContent.frontmatter.layout];
  if (!layoutHTML){
    layoutHTML = fs.readFileSync(layoutPathPrefix+sourceContent.frontmatter.layout+".html", 'utf8');
    //first pull in all includes in html
    layoutHTML = ssiParser(layoutPathPrefix+"/dummy", layoutHTML); //needs file path not just dir, hence dummy
    layoutHTML = hb.compile(layoutHTML);

    compiledLayouts[sourceContent.frontmatter.layout] = layoutHTML;
  }

  sourceContent.frontmatter.contents = sourceContent.content;

  //and then parse through for "mustache-y" syntax...using handlebars
  var finalHTML = layoutHTML(sourceContent.frontmatter);
  //finalHTML = finalHTML.replace(/\r?\n|\r/g, '');

  //Check if the path already exists and warn
  fs.stat(outputFilePath, function(err, stats){
    if(err || forced){
      fs.writeFileSync(outputFilePath, finalHTML, 'utf8');
      console.log("converted: "+inputFilePath+"->"+outputFilePath);
    }
    else{
      console.log("WARNING: file "+outputFilePath+" already exists.");
    }
  });
}

function convertFilesInPath(inputPath, outputPath) {
  //make sure paths are slash terminated
  inputPath = (inputPath.lastIndexOf('/') === inputPath.length -1) ? inputPath : inputPath + '/' ;
  outputPath = (outputPath.lastIndexOf('/') === outputPath.length -1) ? outputPath : outputPath + '/' ;

  files = fs.readdirSync(path.resolve(inputPath));
  files.forEach(function(file) {
    if(fs.lstatSync(inputPath + file).isDirectory()) {
      convertFilesInPath(inputPath + file, outputPath);
      return;
    } else if (file.substr(-2) != 'md') {
      return;
    }

    if(!fs.existsSync(outputPath)) {
      fs.mkdirSync(outputPath);
    }

    renderToHtml(inputPath+ file, outputPath + stripExtension(file) + '.html');
  });
}

/**
  * returns an array, first object is the JSON frontmatter as an object, second is the
  * text with the front matter stripped out
  */
function processMarkupContent(data) {
  //strip out json front-matter
  var parts = data.split(/---/);
  var jsonFM, jsonContent;
  if (parts[0].length < 1) {
    throw new Error("missing frontmatter");
  }
  try {
    jsonFM = JSON.parse(parts[0]);

    contentArr = parts[1].trim().split(/(?=\[[a-z:_]+\]+)/);
    for (var i=0; i<contentArr.length; i++){
      var [fullKey, iContent] = contentArr[i].split(']');

      var [key, type] = fullKey.slice(1).split(':');
      if (type == 'md'){
        var parser   = new commonmark.Parser();
        var renderer = new commonmark.HtmlRenderer();
        jsonFM[key] = renderer.render(parser.parse(iContent));
      }
      else{
        jsonFM[key] = iContent;
      }
    }
  } catch(e) {
    console.error("[frontmatter] err parsing json:"+parts[0], e);
  }
  parts.shift();

  return {
    frontmatter : jsonFM,
    content: parts.join('---') // creo que es lo mismo que hacer toString()
  };
}

convertFilesInPath(args[0], args[1]);

var outputPath = (args[1].lastIndexOf('/') === args[1].length -1) ? args[1] : args[1] + '/';
for(var i=0; i<collectionPages.length; i++){
  var cPage = collectionPages[i];
  cPage.content.frontmatter.jsons = collectionJson;
  processContentAndSaveFile(cPage.inputFilePath, cPage.outputFilePath, cPage.content);
}
