#!/usr/bin/env node

var fs = require('fs'),
    commonmark = require('commonmark'),
    moment = require('moment'),
    ssiParser = require('tiny-ssi'),
    hb = require('handlebars'),
    path = require('path'),
    fsx = require('fs-extra'),
    cmdArgs = require('command-line-args');

const argsDef = [
  { name: 'clear-all', alias: 'c', type: Boolean},
  { name: 'verbose', alias: 'v', type: Boolean }];

const argOptions = cmdArgs(argsDef);

var args = process.argv.slice(2);

//make sure paths are slash terminated
var inputPath = (args[0].lastIndexOf('/') === args[0].length -1) ? args[0] : args[0] + '/';
var outputPath = (args[1].lastIndexOf('/') === args[1].length -1) ? args[1] : args[1] + '/';
var layoutPathPrefix = (args[2].lastIndexOf('/') === args[2].length -1) ? args[2] : args[2] + '/';
var assetsPath = outputPath + 'assets/';

var compiledLayouts = {};
var collectionPages = [];
var collectionJson = [];

hb.registerHelper('json', function(obj) {
  return JSON.stringify(obj);
});

if(layoutPathPrefix.slice(-1) !== '/') layoutPathPrefix += '/';

function stripExtension(fileName) {
  return fileName.substr(0, fileName.lastIndexOf('.'));
}

function renderToHtml(inputFilePath, outputFilePath) {
  var fileContent = fs.readFileSync(inputFilePath, 'utf8');
  var res = processMarkupContent(fileContent);
  if(res.frontmatter) {
    if (res.frontmatter.mode == 'collection'){
      collectionPages.push({
        inputFilePath: inputFilePath,
        outputFilePath: outputFilePath,
        content: res
      });
    }
    else{
      processContentAndSaveFile(inputFilePath, outputFilePath, res);
      if(res.frontmatter.json){
        collectionJson.push(res.frontmatter.json);
      }
    }
  } else {
    console.warn(inputFilePath + " is missing the Frontmatter section!")
  }
}

function processContentAndSaveFile(inputFilePath, outputFilePath, sourceContent){
  sourceContent.frontmatter.date = sourceContent.frontmatter.date ? moment(sourceContent.frontmatter.date).format('MMMM Do YYYY') : moment().format('MMMM Do YYYY');

  sourceContent.frontmatter.layout = sourceContent.frontmatter.layout || "layout"; //default to page layout

  var layoutHTML = compiledLayouts[sourceContent.frontmatter.layout];
  if (!layoutHTML){
    layoutHTML = fs.readFileSync(layoutPathPrefix+sourceContent.frontmatter.layout+".html", 'utf8');
    //first pull in all includes in html
    layoutHTML = ssiParser(layoutPathPrefix+"/dummy", layoutHTML); //needs file path not just dir, hence dummy
    layoutHTML = hb.compile(layoutHTML);

    compiledLayouts[sourceContent.frontmatter.layout] = layoutHTML;
  }

  sourceContent.frontmatter.contents = sourceContent.content;

  //and then parse through for "mustache-y" syntax...using handlebars
  var finalHTML = layoutHTML(sourceContent.frontmatter);
  //finalHTML = finalHTML.replace(/\r?\n|\r/g, '');

  //Check if the path already exists and warn
  fs.stat(outputFilePath, function(err, stats){
    if(err){
      fs.writeFileSync(outputFilePath, finalHTML, 'utf8');
      console.log("converted: " + inputFilePath + '->' + outputFilePath);
    }
    else{
      console.warn("WARNING: file " + outputFilePath + " already exists.");
    }
  });
}

function convertFilesInPath(inputPath, outputPath) {
  if(!fs.existsSync(outputPath)) {
    fs.mkdirSync(outputPath);
  }

  files = fs.readdirSync(path.resolve(inputPath));

  files.forEach(function(file) {
    if(fs.lstatSync(inputPath + file).isDirectory()) {

      if (file == 'assets'){
        try {
          fsx.copySync(inputPath + file, assetsPath, {'overwrite': false, 'errorOnExist': true});
        }
        catch(e){
          console.warn("WARNING: file " + e + '.');
        }
      }
      else{
        convertFilesInPath(inputPath + file + '/', outputPath);
      }
      return;

    } else if (file.substr(-2) != 'md') {
      return;
    }

    renderToHtml(inputPath+ file, outputPath + stripExtension(file) + '.html');
  });
}

/**
  * returns an array, first object is the JSON frontmatter as an object, second is the
  * text with the front matter stripped out
  */
function processMarkupContent(data) {
  //strip out json front-matter
  var parts = data.split(/---/);
  var jsonFM, jsonContent;
  if (parts[0].length < 1) {
    throw new Error("missing frontmatter");
  }
  try {
    jsonFM = JSON.parse(parts[0]);

    contentArr = parts[1].trim().split(/(?=\[[a-z:_]+\]+)/);
    for (var i=0; i<contentArr.length; i++){

      var endFullKeyIdx = contentArr[i].indexOf("]");
      var fullKey = contentArr[i].slice(1, endFullKeyIdx);
      var iContent = contentArr[i].substr(endFullKeyIdx+1);

      var [key, type] = fullKey.split(':');

      var keyVal = '';
      switch(type){
        case 'md':
          var parser   = new commonmark.Parser();
          var renderer = new commonmark.HtmlRenderer();
          keyVal = renderer.render(parser.parse(iContent));
          break;

        case 'json':
          keyVal = JSON.parse(iContent);
          break;

        default:
          keyVal = iContent;
      }
      jsonFM[key] = keyVal;
    }
  } catch(e) {
    console.error("[frontmatter] err parsing file:" + parts[0], e);
  }
  parts.shift();

  return {
    frontmatter : jsonFM,
    content: parts.join('---') // creo que es lo mismo que hacer toString()
  };
}

function copyWebsiteAssets(){
  if(!fs.existsSync(assetsPath)) {
    fs.mkdirSync(assetsPath);
  }
  try {
    fsx.copySync('./assets/', assetsPath, {'overwrite': false, 'errorOnExist': false});
  }
  catch(e){
    console.warn("ERROR: file " + e + '.');
  }
}

function convertCollectionFiles(){
  for(var i=0; i<collectionPages.length; i++){
    var cPage = collectionPages[i];
    cPage.content.frontmatter.jsons = collectionJson;
    processContentAndSaveFile(cPage.inputFilePath, cPage.outputFilePath, cPage.content);
  }
}

if (argOptions['clear-all']){
  fsx.removeSync(outputPath);
  fs.mkdirSync(outputPath);
}

copyWebsiteAssets();
convertFilesInPath(inputPath, outputPath);
convertCollectionFiles();
